// Inclure les biblioth√®ques n√©cessaires
#include <ESP8266WiFi.h> // Biblioth√®que pour la fonctionnalit√© Wi-Fi de l'ESP8266
#include <ESPAsyncWebServer.h> // Biblioth√®que pour la fonctionnalit√© de serveur web asynchrone
#include <ArduinoJson.h> // Biblioth√®que pour la s√©rialisation et la d√©s√©rialisation JSON
#include <Stepper.h>

/* ----------- Configuration Wi-Fi ----------- */
const char* WIFI_SSID = "N1"; // SSID du r√©seau Wi-Fi
const char* WIFI_PASSWORD = "yannyann"; // Mot de passe du r√©seau Wi-Fi

/* ----------- Configuration WebSocket ----------- */
AsyncWebServer server(80); // Cr√©er un serveur web asynchrone sur le port 80
AsyncWebSocket ws("/ws"); // Cr√©er un point de terminaison WebSocket √† "/ws"

/* ----------- Variables d'√©tat globales ----------- */
String lastCommand = ""; // Stocke la derni√®re commande re√ßue
String statusMessage = ""; // Stocke le message d'√©tat √† envoyer
String notif = "false";
String posi  = "";
int currentPosition = 0;



/* ----------- Minuterie pour la mise √† jour automatique ----------- */
unsigned long lastUpdateTime = 0; // Stocke le dernier temps de mise √† jour
const unsigned long updateInterval = 500; // Intervalle de mise √† jour d√©fini √† 1 seconde (1000 millisecondes)


// D√©finir le nombre de pas par r√©volution pour le moteur 28BYJ-48
const int stepsPerRevolution = 2048;

// D√©finir les pins utilis√©s
Stepper myStepper(stepsPerRevolution, D1, D3, D2, D4); 
// IN1 = D1, IN2 = D3, IN3 = D2, IN4 = D4

/* ----------- Prototypes de fonctions ----------- */
void initWiFi(); // Fonction pour initialiser la connexion Wi-Fi
void initWebSocket(); // Fonction pour initialiser WebSocket
void handleWebSocketCommand(); // Fonction pour g√©rer les commandes WebSocket
void sendAutoUpdate(); // Fonction pour envoyer des mises √† jour automatiques
void onWsEvent(AsyncWebSocket* server, AsyncWebSocketClient* client, AwsEventType type, void* arg, uint8_t* data, size_t len); // Gestionnaire d'√©v√©nements WebSocket
void servo(); // Fonction pour lire les cartes RFID

void setup() {
  Serial.begin(115200); // Initialiser la communication s√©rie √† 115200 bauds
  initWiFi(); // Initialiser la connexion Wi-Fi
  initWebSocket(); // Initialiser WebSocket
  myStepper.setSpeed(10); // Vitesse du moteur (tr/min)
  Serial.println("Moteur pr√™t !");
}

void loop() {

  handleWebSocketCommand(); // G√©rer les commandes WebSocket

  // Mise √† jour r√©guli√®re toutes les 1 seconde
  if (millis() - lastUpdateTime > updateInterval) {
    sendAutoUpdate(); // Envoyer la mise √† jour automatique
    lastUpdateTime = millis(); // Mettre √† jour le dernier temps de mise √† jour
  }

   yield(); // Important pour √©viter reset watchdog
}



/* ----------- Traitement des commandes ----------- */
void handleWebSocketCommand() {
  if (lastCommand.isEmpty()) return;

  int divisor = lastCommand.toInt();

  // V√©rification de s√©curit√©
  if (divisor <= 0 || divisor > 2048) {
    Serial.printf("‚ö†Ô∏è Diviseur invalide ou hors limite : %s\n", lastCommand.c_str());
    lastCommand = "";
    return;
  }

  // Calcul et mouvement
  int stepsToMove = stepsPerRevolution / divisor;
  myStepper.step(stepsToMove);
  currentPosition += stepsToMove;
  posi = String(currentPosition);

  Serial.printf("‚úÖ Commande: diviseur=%d ‚Üí %d pas. Position actuelle = %d\n", divisor, stepsToMove, currentPosition);

  lastCommand = "";
}


/* ----------- Envoyer une mise √† jour automatique ----------- */
void sendAutoUpdate() {

  StaticJsonDocument<512> doc; // Cr√©er un document JSON


 doc["Ecran1"] = millis();
  doc["Ecran2"] = statusMessage;
  doc["Ecran3"] =  "val";
    doc["Ecran4"] = "00";
 
  

  doc["Indicateur1"] = "posi";
  doc["Indicateur2"] = 0.01;
  doc["Indicateur3"] = 0.01;

  doc["Bulb1"]  = "led1";
  doc["Bulb2"]  = "led2";
  doc["Bulb3"]  = "led3";
  doc["Bulb4"]  = "led4";

 
 

  // Ajouter les informations d'√©tat de l'ESP au document JSON

  doc["notif"] = notif;
  doc["status"] = "auto-update";
  doc["message"] = statusMessage;
  doc["Wifi"] = WiFi.SSID();
  doc["ip_address"] = WiFi.localIP().toString();
  doc["mac_address"] = WiFi.macAddress();
  doc["signal_strength"] = WiFi.RSSI();
  doc["gateway_ip"] = WiFi.gatewayIP().toString();
  doc["free_memory"] = ESP.getFreeHeap();
  doc["flash_memory"] = ESP.getFlashChipSize();
 
  String payload;
  serializeJson(doc, payload); // S√©rialiser le document JSON en cha√Æne de caract√®res
  ws.textAll(payload); // Envoyer la cha√Æne JSON √† tous les clients WebSocket
 notif = "false"  ;


 // Serial.println("üîÑ Mise √† jour automatique envoy√©e"); // Afficher le message de mise √† jour envoy√©e
}











/* ----------- Initialisation Wi-Fi ----------- */
void initWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD); // Se connecter au r√©seau Wi-Fi
  Serial.print("Connexion au WiFi .."); // Afficher le message de connexion

  while (WiFi.status() != WL_CONNECTED) { // Attendre la connexion
    Serial.print('.'); // Afficher des points pendant la connexion
    delay(1000); // Attendre 1 seconde
  }

  Serial.println(WiFi.localIP()); // Afficher l'adresse IP locale
}

/* ----------- Initialisation WebSocket ----------- */
void initWebSocket() {
  ws.onEvent(onWsEvent); // D√©finir le gestionnaire d'√©v√©nements WebSocket
  server.addHandler(&ws); // Ajouter le gestionnaire WebSocket au serveur
  server.begin(); // D√©marrer le serveur
}

/* ----------- Gestionnaire d'√©v√©nements WebSocket ----------- */
void onWsEvent(AsyncWebSocket* server, AsyncWebSocketClient* client, AwsEventType type, void* arg, uint8_t* data, size_t len) {
  switch (type) {
    case WS_EVT_CONNECT: // Client connect√©
      Serial.printf("Client WebSocket #%u connect√© depuis %s\n", client->id(), client->remoteIP().toString().c_str());
      break;
    case WS_EVT_DISCONNECT: // Client d√©connect√©
      Serial.printf("Client WebSocket #%u d√©connect√©\n", client->id());
      break;
    case WS_EVT_DATA: // Donn√©es re√ßues
      AwsFrameInfo* info = (AwsFrameInfo*)arg;
      if (info->final && info->index == 0 && info->len == len && info->opcode == WS_TEXT) {
        data[len] = 0; // Terminer les donn√©es par un caract√®re nul
        lastCommand = (char*)data; // Stocker la commande re√ßue
        Serial.printf("Commande re√ßue : %s\n", (char*)data); // Afficher la commande re√ßue
      }
      break;
  }
}
